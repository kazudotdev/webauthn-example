/* esm.sh - esbuild bundle(pvtsutils@1.3.5) denonext production */
import { Buffer as __Buffer$ } from "node:buffer";
var y="[object ArrayBuffer]",u=class s{static isArrayBuffer(t){return Object.prototype.toString.call(t)===y}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,r){if(t.constructor===r)return t;if(this.isArrayBuffer(t))return new r(t);if(this.isArrayBufferView(t))return new r(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,r){let e=s.toUint8Array(t),n=s.toUint8Array(r);if(e.length!==n.byteLength)return!1;for(let i=0;i<e.length;i++)if(e[i]!==n[i])return!1;return!0}static concat(...t){let r;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?r=t[0]:t[t.length-1]instanceof Function?r=t.slice(0,t.length-1):r=t;let e=0;for(let f of r)e+=f.byteLength;let n=new Uint8Array(e),i=0;for(let f of r){let c=this.toUint8Array(f);n.set(c,i),i+=c.length}return t[t.length-1]instanceof Function?this.toView(n,t[t.length-1]):n.buffer}},l="string",g=/^[0-9a-f]+$/i,A=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,w=/^[a-zA-Z0-9-_]+$/,a=class{static fromString(t){let r=unescape(encodeURIComponent(t)),e=new Uint8Array(r.length);for(let n=0;n<r.length;n++)e[n]=r.charCodeAt(n);return e.buffer}static toString(t){let r=u.toUint8Array(t),e="";for(let i=0;i<r.length;i++)e+=String.fromCharCode(r[i]);return decodeURIComponent(escape(e))}},o=class{static toString(t,r=!1){let e=u.toArrayBuffer(t),n=new DataView(e),i="";for(let f=0;f<e.byteLength;f+=2){let c=n.getUint16(f,r);i+=String.fromCharCode(c)}return i}static fromString(t,r=!1){let e=new ArrayBuffer(t.length*2),n=new DataView(e);for(let i=0;i<t.length;i++)n.setUint16(i*2,t.charCodeAt(i),r);return e}},h=class s{static isHex(t){return typeof t===l&&g.test(t)}static isBase64(t){return typeof t===l&&A.test(t)}static isBase64Url(t){return typeof t===l&&w.test(t)}static ToString(t,r="utf8"){let e=u.toUint8Array(t);switch(r.toLowerCase()){case"utf8":return this.ToUtf8String(e);case"binary":return this.ToBinary(e);case"hex":return this.ToHex(e);case"base64":return this.ToBase64(e);case"base64url":return this.ToBase64Url(e);case"utf16le":return o.toString(e,!0);case"utf16":case"utf16be":return o.toString(e);default:throw new Error(`Unknown type of encoding '${r}'`)}}static FromString(t,r="utf8"){if(!t)return new ArrayBuffer(0);switch(r.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return o.fromString(t,!0);case"utf16":case"utf16be":return o.fromString(t);default:throw new Error(`Unknown type of encoding '${r}'`)}}static ToBase64(t){let r=u.toUint8Array(t);if(typeof btoa<"u"){let e=this.ToString(r,"binary");return btoa(e)}else return __Buffer$.from(r).toString("base64")}static FromBase64(t){let r=this.formatString(t);if(!r)return new ArrayBuffer(0);if(!s.isBase64(r))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(r)):new Uint8Array(__Buffer$.from(r,"base64")).buffer}static FromBase64Url(t){let r=this.formatString(t);if(!r)return new ArrayBuffer(0);if(!s.isBase64Url(r))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(r.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,r=s.DEFAULT_UTF8_ENCODING){switch(r){case"ascii":return this.FromBinary(t);case"utf8":return a.fromString(t);case"utf16":case"utf16be":return o.fromString(t);case"utf16le":case"usc2":return o.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${r}'`)}}static ToUtf8String(t,r=s.DEFAULT_UTF8_ENCODING){switch(r){case"ascii":return this.ToBinary(t);case"utf8":return a.toString(t);case"utf16":case"utf16be":return o.toString(t);case"utf16le":case"usc2":return o.toString(t,!0);default:throw new Error(`Unknown type of encoding '${r}'`)}}static FromBinary(t){let r=t.length,e=new Uint8Array(r);for(let n=0;n<r;n++)e[n]=t.charCodeAt(n);return e.buffer}static ToBinary(t){let r=u.toUint8Array(t),e="";for(let n=0;n<r.length;n++)e+=String.fromCharCode(r[n]);return e}static ToHex(t){let r=u.toUint8Array(t),e="",n=r.length;for(let i=0;i<n;i++){let f=r[i];f<16&&(e+="0"),e+=f.toString(16)}return e}static FromHex(t){let r=this.formatString(t);if(!r)return new ArrayBuffer(0);if(!s.isHex(r))throw new TypeError("Argument 'hexString' is not HEX encoded");r.length%2&&(r=`0${r}`);let e=new Uint8Array(r.length/2);for(let n=0;n<r.length;n=n+2){let i=r.slice(n,n+2);e[n/2]=parseInt(i,16)}return e.buffer}static ToUtf16String(t,r=!1){return o.toString(t,r)}static FromUtf16String(t,r=!1){return o.fromString(t,r)}static Base64Padding(t){let r=4-t.length%4;if(r<4)for(let e=0;e<r;e++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};h.DEFAULT_UTF8_ENCODING="utf8";function b(s,...t){let r=arguments[0];for(let e=1;e<arguments.length;e++){let n=arguments[e];for(let i in n)r[i]=n[i]}return r}function B(...s){let t=s.map(n=>n.byteLength).reduce((n,i)=>n+i),r=new Uint8Array(t),e=0;return s.map(n=>new Uint8Array(n)).forEach(n=>{for(let i of n)r[e++]=i}),r.buffer}function m(s,t){if(!(s&&t)||s.byteLength!==t.byteLength)return!1;let r=new Uint8Array(s),e=new Uint8Array(t);for(let n=0;n<s.byteLength;n++)if(r[n]!==e[n])return!1;return!0}export{u as BufferSourceConverter,h as Convert,b as assign,B as combine,m as isEqual};
/*! Bundled license information:

pvtsutils/build/index.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2022 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)
*/
//# sourceMappingURL=pvtsutils.mjs.map